<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="keon,undefined"><meta name="copyright" content="keon"><title>大概是一些读书笔记 | keon随便写写</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ae0586f75159e5097cb79871b2fdb3a1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">keon</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><nav class="https://raw.githubusercontent.com/awdclijn/awdclijn.github.io/master/img/kim-holtermand-reflections.jpg" id="nav" style="background-image: url(https://raw.githubusercontent.com/awdclijn/awdclijn.github.io/master/img/kim-holtermand-reflections.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">keon随便写写</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">keon随便写写</div><div id="site-sub-title">大概是一些读书笔记</div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/awdclijn" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="http://weibo.com/awdclijn" target="_blank"><i class="fa fa-weibo"></i></a><a class="social-icon" href="mailto:awdclijn@gamil.com" target="_blank"><i class="fa fa-envelope"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/09/论软件可靠性设计技术的应用/">论软件可靠性设计技术的应用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-09</time><div class="content"><p>【摘要】<br>2017年4月份，某股份制银行启动了新征信管理平台的系统项目，本人所在的大数据支持处室负责了数据存储、查询及数据标准化等功能的建设，本人作为项目经办负责技术方案的管理和设计。征信管理平台是我行风险控制的重要部分，维护有个人、对公征信、互联网小贷、电信运营商等数据。征信管理平台承载了大量业务在风险控制环节对数据的诉求，如新发卡、贷前、贷中等关键业务流程，因此行内提出了较高的可靠性要求。为达到该系统的可靠性要求，本人带领合作公司团队对系统的运行环境和特点等进行分析，根据分析出的结果制定了提高系统可靠性的措施：一是采用了健康检查的思路，出现故障后可自动拉起应用并告警；二是降低主流程复杂度，将主流程外的处理通过队列异步处理。三是容错机制的设计，建议业务采购多家供应商的接口，形成主备模式。至从2017年6月开放第一批接口，截至2017年年末已接入数据源40余个，系统投产后大量的外部征信数据能在有效期内得到复用，节约了大量的费用，同时系统的高性能、高可用性的特点也得到业务部门的一致好评。</p>
<p>【正文】<br>随着银行业的快速发展，各业务部门对风险管理的要求越来越高，需要更加丰富的征信数据帮忙完成业务流程，同时旧征信平台中使用的传统应用和数据库架构已无法满足业务发展的需求，因此行内提出了建设新征信管理平台的诉求。大量的征信外部数据也是对大数据平台数据源的一个完善，因此我所在的处室承担了相关数据存储、查询及数据标准化等功能的建设（本文中仅对实时应用部分讨论，离线部分不具体展开），本人负责技术方案的管理和设计。总体上系统采用了微服务的架构：1、查询服务按业务领域进行划分，有征信服务、运营商服务、个人属性服务等负责具体数据的查询、主备供应商的切换及数据的标准化，并且将查询后的数据及相关的日志信息防止队列中间件中；2、数据回写服务负责从队列将数据入库，并根据规则生成有效期等字段，以便数据复用。3、服务治理的相关组件，注册中心负责管理服务的元信息；配置中心负责管理各服务的配置文件；网关负责交易请求的路由。4、数据存储上采用了分布式的中间件Elasticsearch，过程中直接存取非结构化数据，减少关联查询。</p>
<p>征信管理平台涉及的关键业务流程多，访问量大，因此行内提出了较高的可靠性要求。要提高系统的可靠性指标，团队首先进行可靠性影响分析，主要采用了故障树分析方法。故障树分析方法是一种自顶向下的软件可靠性分析方法，从软件系统不希望发生的事件向下逐步追查导致事件发生的原因，直至基本事件，从而确定软件故障的原因。经过分析，我们找出了以下导致故障发生的基本事件：</p>
<p>一、运行硬件，应用所依赖的运行硬件并不是完全可靠的，随着时间推移，硬件会发生老化从而产生故障。</p>
<p>二、模块规模及内部结构的复杂度，模块的规模越大、复杂度越高，其开发测试的难度也越大，我们需要尽量降低主流程的复杂度，让整个架构实现更加可控。</p>
<p>三、外部依赖，征信数据的来源是第三方的数据服务提供商，每个服务提供商的服务质量参差不齐。虽然有商务合同进行约束，但实际情况中经常会出现无法提供服务的情况。</p>
<p>常用的软件可靠性技术有容错设计、检错设计、降低复杂度设计等。容错设计可以通过冗余或者备份的方式代替故障服务，从而维护软件系统的正常运行；检错设计是当软件系统出现故障时能及时发现并告警提示维护人员处理的能力；降低复杂度设计的思想是保证实现软件功能的基础上，简化软件结构，优化软件数据流向，降低软件复杂度，从而提高软件可靠性。根据以上的分析，结合行内的技术特点，我们制定了如下的可靠性设计方案。</p>
<p>一、在整体的部署架构中采用多活的方式进行部署，建立健康检查的机制，并且与行内集中告警平台对接。</p>
<p>应用服务以多实例的方式部署在行内已有docker云平台中，应用暴露接口供云平台进行健康检查，若长时间判断为不健康时，云平台可自动拉起新的服务实例，关闭故障实例，并进行统一告警。同时在应用逻辑中提供了重试的请求机制，通过网关服务进行流量分发时，若无法分发至目标服务，则会重试分发逻辑。如仍无法分发，则会从注册中心中挑选另一个可用实例进行分发路由，保障服务的连续。</p>
<p>二、降低业务主流程程序中的复杂度，将回写数据、日志信息等放入到kafka消息队列中间件中，后续由其他应用进行数据消费处理。</p>
<p>征信数据在业务定义的有效期内可反复使用，节约外发请求第三方的费用，因此需要将查询后的数据结果进行存储。在该方案设计中，查询后的数据会直接放入到消息队列中，由数据回写服务根据业务配置的有效期规则，计算数据有效期后进行入库。该设计将查询和写入操作解耦，模块之间消除依赖，查询服务外的应用出现故障，最坏结果只是会造成服务降级，无法查得存量数据，并不会影响正常的业务的开展。由于各服务的轻量级设计思路，后续的维护复杂度降低，便于评估变更影响，提高整个系统的可靠性。</p>
<p>三、采用了冗余设计的思路，向业务建议采购多个提供相同服务的数据提供商形成服务的主备架构。</p>
<p>第三方的服务质量及数据质量都无法控制，从设计上规划了两种策略进行冗余，1）主备供应商，即查询时根据业务配置的主供应商进行查询，业务可按需进行切换；2）优先级策略，即优先查询高优先级的供应商，若无法得到满足业务的服务（如第三方服务无响应或关键字段为空），则继续查询下一优先级的服务，保证业务不受第三方影响。这个设计思路也得到了业务的高度认可，在某次快速发卡（现场申请虚拟信用卡进行消费）的业务场景中，第三方接口突然服务中断，业务按指引进行了供应商优先级的切换，快速的解决了问题，保证了业务不受影响。</p>
<p>该项目架构稳定后，本人于17年年底交接了该系统的相关事项，截至当时，已接入数据源40余个，每日的查询量已接近千万级。在项目组各位的努力下，该系统也得到了各部门的一致好评。通过本次的项目架构实践，我学习了提高可靠性相关的分析方法和设计思路，也深刻体会到了系统架构设计和选择对项目影响的重要性。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/09/论软件系统架构评估/">论软件系统架构评估</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-09</time><div class="content"><pre><code>2017年4月份，某股份制银行启动了新征信管理平台的系统项目，本人所在的大数据支持处室负责了数据存储、查询及数据标准化等功能的建设，本人作为项目经办负责技术方案的管理和设计。征信管理平台是我行风险控制的重要部分，维护有个人、对公征信、互联网小贷、电信运营商等数据。征信管理平台承载了大量业务在风险控制环节对数据的诉求，如新发卡、贷前、贷中等关键业务流程。
本文论述了软件系统的架构评估，首先分析了软件架构评估所普遍关注的质量属性并阐述了其性能、可用性、可修改性和安全性的具体含义。整个系统采用了微服务的架构设计方法。在架构设计完成之后，对SA评估采用了基于场景的评估方式中的体系结构权衡分析方法ATAM，并详细描述了其评估过程，项目评估小组经过对项目的风险点、敏感点和权衡点的讨论后生成了质量效应树。目前系统已稳定运行一年多，从而验证了该项目采用ATAM架构评估保证了系统的顺利完成。

随着银行业的快速发展，各业务部对风险管理的要求越来越高，需要更加丰富的征信数据帮忙完成业务流程，同时旧征信平台中使用的传统应用和数据库架构已无法满足业务发展的需求，因此行内提出了建设新征信管理平台的诉求。大量的征信外部数据也是对大数据平台数据源的一个完善，因此我所在的处室承担了相关数据存储、查询及数据标准化等功能的建设（本文中仅对实时应用部分讨论，离线部分不具体展开），本人负责技术方案的管理和设计。
</code></pre><p>总体上系统采用了微服务的架构：1、查询服务按业务领域进行划分，有征信服务、运营商服务、个人属性服务等负责具体数据的查询、主备供应商的切换及数据的标准化，并且将查询后的数据及相关的日志信息防止队列中间件中；2、数据回写服务负责从队列将数据入库，并根据规则生成有效期等字段，以便数据复用。3、服务治理的相关组件，注册中心负责管理服务的元信息；配置中心负责管理各服务的配置文件；网关负责交易请求的路由。4、数据存储上采用了分布式的中间件Elasticsearch，过程中直接存取非结构化数据，减少关联查询。征信管理平台涉及的关键业务流程多，访问量大，因此行内提出了较多的质量属性要求，下面先介绍下软件架构评估的质量属性。</p>
<pre><code>架构评估是软件开发过程中的重要环节，在软件架构评估中的质量属性有：性能、可用性、可修改性、安全性、可测试性、可靠性和易用性等。其中前4个质量属性是质量效应树的重要组成部分。性能是指系统的响应能力，即经过多长时间对事件做出响应。可用性是指系统能够正常运行的比例，通过用两次故障之间的时间长度或出现故障时系统能够恢复的速度来表示。可修改性是指系统能以较高的性价比对系统做出变更的能力。安全性是指系统能够向合法用户提供服务，同时拒绝非授权用户使用或拒绝服务的能力。
常用的架构评估方法有：基于问卷调查的评估方式、基于场景的评估方式和基于度量的评估方式。基于问卷调查的评估方式是由多个评估专家通过调查问卷的方式回答问卷中的问题，对多个评估结果进行综合，最终得到最终结果。其评价的具有主观性不太适合本项目。基于度量的评估方式虽然评价比较客观，但是需要评估者对系统的架构有精确的了解，也不太适合本项目。而基于场景的评估要求评估者对系统中等了解，评价比较主观，故本项目采用了基于场景的评估方式。基于场景的评估方式又分为架构权衡分析法ATAM，软件架构分析法SAAM和成本效益分析法CBAM。本项目中根据不同质量属性使用了ATAM作为系统架构评估的方法。

在使用ATAM进行架构评估时，我们根据项目需要成立了项目评估小组。其主要成员包括：评估小组负责人、项目决策者、架构设计师、用户、开发人员、测试人员、系统部署人员等项目干系人。架构的评估经历了描述和介绍阶段、调查和分析阶段、测试阶段和报告阶段四个阶段。下面我分别从这四个阶段进行介绍。

在描述和介绍阶段，由于项目评估成员有部分人员对ATAM并不熟悉，因此项目组首先学习了ATAM的方法。它是一种基于场景的软件架构评估方法，对系统的多个质量属性基于场景进行评估。通过该评估确认系统存在的风险，并检查各自的非功能性需求是否满足需求。业务重点阐述了系统的目的和举例说明了使用的场景，我也和大家介绍了本次项目中采用的微服务架构，并解析了各模块的功能。

在调查分析阶段，业务部门提出了性能及高可用的要求，因为大量的业务场景需要使用到这些数据，并且部分场景对时间非常敏感。另外开发人员提出为了当不断增加数据供应商时，需要快速的进行接入，保证系统的开发效率及系统修改性，可以进行并行开发。

针对这些场景我们分析了项目开发过程中的风险点、敏感点和权衡点。经过分析，该项目中存在以下风险点：当第三方供应商无法提供服务时，会直接影响业务可用性；敏感点有：用户的加密级别、漏洞规则的修改。权衡点有：为提高可用性，需增加主备模式，当主供应商失效时，能切换至选供应商继续提供服务，但因为主备供应商的报文格式、数据字典都有差异，需要进行标准化，势必影响系统的可修改性。

在测试阶段：经过评估小组集体讨论，确定了不同场景的优先级如下：系统的可用性最高，性能其次，可修改性较低。在保证系统可用性方面，在流量捕获部分使用双机热备技术，在两个捕获系统之间设置心跳，当一台捕获系统出问题，另一台捕获设备接管。在流量自动化分析部分，采用了集群部署技术，一台分析设备出问题，不会影响整个分析系统。在保证数据安全性方面，磁盘采用企业磁盘阵列raid5机制。在用户数据安全性方面，采用了非对称加密及信息摘要技术。

最后形成了评估报告，经过对架构的评估，确定了系统的风险点、敏感点、权衡点和非风险点，最后以文档的形式表现。其包括的内容包括：架构分析方法文档、架构的不同场景及各自的优先级、质量效应树、风险点决策、非风险点决策及每次的评估会议记录。

该项目开发工作于2016年8月完工，系统上线后，我们的安全分析人员和客户使用该系统对互联网流量进行漏洞挖掘，一共产生了150种以上的web流量攻击流量特征和5个未知web漏洞。在国家某安全中心网研室的其他项目中起到了支撑作用，尤其是某变量覆盖漏洞、某文件写入漏洞，某sql注入漏洞在项目使用过程中取得了一定得效果，得到了好评。为开展互联网安全事件得防御、发现、预警和协调处置等工作提供了数据依据，更好的维护了国家公共互联网安全，保障基础信息网络和重要信息系统的安全运行。
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/09/论软件架构的选择/">论软件架构的选择</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-09</time><div class="content"><p>论文摘要</p>
<pre><code>2017年4月份，某股份制银行启动了新征信管理平台的系统项目，本人所在的大数据支持处室负责了数据存储、查询及数据标准化等功能的建设，本人作为项目经办负责技术方案的管理和设计。征信管理平台是我行风险控制的重要部分，维护有个人、对公征信、互联网小贷、电信运营商等数据。征信管理平台承载了大量业务在风险控制环节对数据的诉求，如新发卡、贷前、贷中等关键业务流程。本文介绍了几种主要架构风格及特点，论述了该项目在软件架构选择过程中，为何选择了三种风格的组合。最后，文章总结了采用该组合风格后带来的好处及缺点。
</code></pre><p>论文正文</p>
<p>背景介绍</p>
<pre><code>随着银行业的快速发展，各业务部对风险管理的要求越来越高，需要更加丰富的征信数据帮忙完成业务流程，同时旧征信平台中使用的传统应用和数据库架构已无法满足业务发展的需求，因此行内提出了建设新征信管理平台的诉求。大量的征信外部数据也是对大数据平台数据源的一个完善，因此我所在的处室承担了相关数据存储、查询及数据标准化等功能的建设（本文中仅对实时应用部分讨论，离线部分不具体展开），本人负责技术方案的管理和设计。
</code></pre><p>主要架构风格介绍</p>
<pre><code>在基本需求确认后，我们开始了系统架构的选择，首先是对常用的架构风格进行了分析。管道/过滤器风格，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。
基于事件的隐式调用风格，其思想是构件不直接调用一个过程，而是触发或广播一个或多个事件。系统中的其它构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程，这样，一个事件的触发就导致了另一模块中的过程的调用。
微服务风格，是指开发一个单个小型的但有业务功能的服务，每个服务都有自己的处理和轻量通讯机制，可以部署在单个或多个服务器上。微服务也指一种种松耦合的、有一定的有界上下文的面向服务架构。
三层分层架构，将整个业务应用划分为界面层、业务逻辑层、数据访问层，目的是为了“高内聚低耦合”的思想。
</code></pre><p>架构风格选择</p>
<pre><code>结合业务需求和行内现有技术框架及系统环境的实际情况，最终我们再整体上选择了微服务架构，部分模块中使用分层架构，事件驱动，数据库系统这三种风格的混合模式。

在系统整体架构选择上，主要考虑了系统的可用性、性能及可扩展性，采用了微服务的风格：1、查询服务按业务领域进行划分，有征信服务、运营商服务、个人属性服务等负责具体数据的查询、主备供应商的切换及数据的标准化，并且将查询后的数据及相关的日志信息防止队列中间件中；2、数据回写服务负责从队列将数据入库，并根据规则生成有效期等字段，以便数据复用。3、服务治理的相关组件，注册中心负责管理服务的元信息；配置中心负责管理各服务的配置文件；网关负责交易请求的路由。4、业务数据存储上采用了分布式的中间件Elasticsearch，过程中直接存取非结构化数据，减少关联查询。按业务领域划分查询服务可以使得扩展更加灵活，不同业务领域的修改不会互相影响，当后续不同领域的数据供应商新增时，只需要新增服务，不需要修改远服务减少影响范围。同时个别繁忙服务需要扩充资源时，也能灵活扩充，不会造成浪费。

在面向业务使用的后台管理服务中，首先我们为了安装方便，采用了B/S架构，整体上将系统分为页面表现层，业务逻辑层及数据持久层这三层。表现层采用jsp文件实现，业务逻辑层为一组java service，数据持久层采用mybatis xml文件实现。这样设计的原因是可以降低层与层之间的依赖，便于各层逻辑的复用，在后期维护的时候，极大地降低了维护成本和维护时间

实际业务需求调研时我们了解到用户在多个地方有审批需求，比如业务机会阶段变更到2阶段时，项目名称修改时，及项目非正常关闭时，考虑到可能还会有其他地方需要审批，而审批是一个比较独立的功能模块，有自己的一系列行为，审批功能可能也会随着外部比如OA系统升级而做修改或替换。所以这里我们采用了事件驱动架构，将审批功能分装成一个独立构件，将启动审批流程过程注册到审批事件中，各个需要的功能界面只需触发审批事件即可。
</code></pre><p>总结</p>
<pre><code>项目耗时4个月时间最终成功上线，上线后得到使用单位用户和领导的高度认可，至今使用已经超过两年，后期维护过程中，用户单位由于业务分工及组织架构调整，项目池要求由原先的按照行业来划分修改为按照地区来划分，由于我们将项目池分类定义在数据库系统中，所以我们很快地就满足了用户的修改需求。另外，我们发现到采用该混合架构也存在一些缺陷，比如B/S分层架构带来的页面查询性能不佳，随着数据量的增加，首页刷新时间一度增加到8秒以上，针对这个问题，我们后来将首页分成几个块用多线程的方式分别独立刷新，现在速度提高至3秒左右。

通过这个项目，本人更进一步了解到系统架构设计的重要性，也意识到各类架构风格只为满足核心业务场景系统需求的本质。
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/12/《Kafka技术内幕》-读书笔记5/">《Kafka技术内幕》--读书笔记5</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><p>消费者的配置信息要指定连接的ZK集群以及消费组编号。消费者客户端会通过消费者连接器(ConsumerConnector)连接ZK集群，获取分配的分区，创建每个主题对应的消息流(KafkaStream),最后迭代消息流，读取每条消息，并完成具体的业务处理逻辑(这里只是简单地打印出收到的每条信息)。</p>
<p>消费者客户端通过消费者连接器读取消息的具体步骤如下。</p>
<ol>
<li>消费者的配置信息指定订阅的主题和主题对应的线程数，每个线程对应一个消息流。</li>
<li>Consumer对象通过配置文件创建基于ZK的消费者连接器。</li>
<li>消费者连接器根据主题和线程数创建多个消息流。</li>
<li>在每个消息流通过循环消费者迭代器(ConsumerIterator)读出消息。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fve31c9uixj315w0hmap1.jpg" alt=""></p></div><a class="more" href="/2018/09/12/《Kafka技术内幕》-读书笔记5/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/08/《Kafka技术内幕》-读书笔记4/">《Kafka技术内幕》--读书笔记4</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><p>Kafka集群的数据需要被不同类型的消费者使用，而不同类型的消费者处理逻辑不同。Kafka使用消费组的概念，允许一组消费者进程对消费工作进行划分。每个消费者都可以配置一个所属的消费组，并且订阅多个主题。Kafka会发送每条消息给每个消费组中的一个消费者迫二程(同一条消息广播给多个消费组，单播给同一组中的消费者)。被订阅主题的所有分区会平均地负载给订阅方，即消费组中的所有消费者。</p>
<p>Kafka采用消费组保证了“一个分区只可被消费组中的一个消费者所消费”，这意味着:</p>
<ol>
<li>在一个消费组中，一个消费者可以消费多个分区。</li>
<li>不同的消费者消费的分区一定不会重复，所有消费者一起消费所有的分区。</li>
<li>在不同消费组中，每个消费组都会悄费所有的分区。</li>
<li>同一个消费组下消费者对分区是互斥的，而不同消费组之间是共享的。</li>
</ol></div><a class="more" href="/2018/09/08/《Kafka技术内幕》-读书笔记4/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/13/《Kafka技术内幕》-读书笔记3/">《Kafka技术内幕》--读书笔记3</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><h1 id="客户端消息发送线程"><a href="#客户端消息发送线程" class="headerlink" title="客户端消息发送线程"></a>客户端消息发送线程</h1><p>我们先按照分区的主副本节点进行分组，把属于同一个节点的所有分区放在一起，合并成一个请求发送。</p>
<p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fu8gxn3kihj30uq0j2n9f.jpg" alt=""></p></div><a class="more" href="/2018/08/13/《Kafka技术内幕》-读书笔记3/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/18/《Kafka技术内幕》-读书笔记2/">《Kafka技术内幕》--读书笔记2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><p>Kafka初期使用Scala编写，早期Scala版本的生产者、消费者和服务端的实现都放在core包下;而最新的客户端使用了Java重新实现，放在clients包下。</p>
<h1 id="新生产者"><a href="#新生产者" class="headerlink" title="新生产者"></a>新生产者</h1><p>新的生产者应用程序使用KafkaProducer对象代表一个生产者客户端进程。生产者要发送消息，并不是直接发送给服务端，而是先在客户端把消息放入队列中，然后由一个消息发送线程从队列中拉取消息，以批量的方式发送消息给服务端。Kafka的记录收集器(RecordAccumulator)负责缓存生产者客户端产生的消息，发送线程(Sender)负责读取记录收集器的批量消息，通过网络发送给服务端。为了保证客户端网络请求的快速响应，Kafka使用选择器(Selector)处理网络连接和读写处理，使用网络连接(NetworkClient)处理客户端网络请求。</p></div><a class="more" href="/2018/07/18/《Kafka技术内幕》-读书笔记2/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/15/《Kafka技术内幕》-读书笔记1/">《Kafka技术内幕》--读书笔记1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>生产者 (producer)应用程序发布事件流到Kafka的一个或多个主题。</li>
<li>消费者 (consumer)应用程序订阅Kafka的一个或多个主题，并处理事件流。</li>
<li>连接器 (connector)将Kafka主题和已有数据源进行连接，数据可以互相导人和导出 。</li>
<li>流处理 (processor)从Kafka主题消费输入流，经过处理后，产生输出流到输出主题。</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftax17fddej30u00liqg7.jpg" alt=""></p></div><a class="more" href="/2018/07/15/《Kafka技术内幕》-读书笔记1/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/13/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-13</time><div class="content"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By keon</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>