<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="keon,undefined"><meta name="copyright" content="keon"><title>大概是一些读书笔记 | keon随便写写</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ae0586f75159e5097cb79871b2fdb3a1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">keon</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><nav class="https://raw.githubusercontent.com/awdclijn/awdclijn.github.io/master/img/kim-holtermand-reflections.jpg" id="nav" style="background-image: url(https://raw.githubusercontent.com/awdclijn/awdclijn.github.io/master/img/kim-holtermand-reflections.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">keon随便写写</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">keon随便写写</div><div id="site-sub-title">大概是一些读书笔记</div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/awdclijn" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="http://weibo.com/awdclijn" target="_blank"><i class="fa fa-weibo"></i></a><a class="social-icon" href="mailto:awdclijn@gamil.com" target="_blank"><i class="fa fa-envelope"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/09/论软件可靠性设计技术的应用/">论软件可靠性设计技术的应用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-09</time><div class="content"><p>【摘要】<br>2017年4月份，某股份制银行启动了新征信管理平台的系统项目，本人所在的大数据支持处室负责了数据存储、查询及数据标准化等功能的建设，本人作为项目经办负责技术方案的管理和设计。征信管理平台是我行风险控制的重要部分，维护有个人、对公征信、互联网小贷、电信运营商等数据。征信管理平台承载了大量业务在风险控制环节对数据的诉求，如新发卡、贷前、贷中等关键业务流程，因此行内提出了较高的可靠性要求。为达到该系统的可靠性要求，本人带领合作公司团队对系统的运行环境和特点等进行分析，根据分析出的结果制定了提高系统可靠性的措施：一是采用了健康检查的思路，出现故障后可自动拉起应用并告警；二是降低主流程复杂度，将主流程外的处理通过队列异步处理。三是容错机制的设计，建议业务采购多家供应商的接口，形成主备模式。至从2017年6月开放第一批接口，截至2017年年末已接入数据源40余个，系统投产后大量的外部征信数据能在有效期内得到复用，节约了大量的费用，同时系统的高性能、高可用性的特点也得到业务部门的一致好评。<br></div><a class="more" href="/2018/11/09/论软件可靠性设计技术的应用/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/09/论软件系统架构评估/">论软件系统架构评估</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-09</time><div class="content"><p>2017年4月份，某股份制银行启动了新征信管理平台的系统项目，本人所在的大数据支持处室负责了数据存储、查询及数据标准化等功能的建设，本人作为项目经办负责技术方案的管理和设计。征信管理平台是我行风险控制的重要部分，维护有个人、对公征信、互联网小贷、电信运营商等数据。征信管理平台承载了大量业务在风险控制环节对数据的诉求，如新发卡、贷前、贷中等关键业务流程。<br>本文论述了软件系统的架构评估，首先分析了软件架构评估所普遍关注的质量属性并阐述了其性能、可用性、可修改性和安全性的具体含义。整个系统采用了微服务的架构设计方法。在架构设计完成之后，对SA评估采用了基于场景的评估方式中的体系结构权衡分析方法ATAM，并详细描述了其评估过程，项目评估小组经过对项目的风险点、敏感点和权衡点的讨论后生成了质量效应树。目前系统已稳定运行一年多，从而验证了该项目采用ATAM架构评估保证了系统的顺利完成。</p>
<p>随着银行业的快速发展，各业务部对风险管理的要求越来越高，需要更加丰富的征信数据帮忙完成业务流程，同时旧征信平台中使用的传统应用和数据库架构已无法满足业务发展的需求，因此行内提出了建设新征信管理平台的诉求。大量的征信外部数据也是对大数据平台数据源的一个完善，因此我所在的处室承担了相关数据存储、查询及数据标准化等功能的建设（本文中仅对实时应用部分讨论，离线部分不具体展开），本人负责技术方案的管理和设计。</p>
<p>总体上系统采用了微服务的架构：1、查询服务按业务领域进行划分，有征信服务、运营商服务、个人属性服务等负责具体数据的查询、主备供应商的切换及数据的标准化，并且将查询后的数据及相关的日志信息防止队列中间件中；2、数据回写服务负责从队列将数据入库，并根据规则生成有效期等字段，以便数据复用。3、服务治理的相关组件，注册中心负责管理服务的元信息；配置中心负责管理各服务的配置文件；网关负责交易请求的路由。4、数据存储上采用了分布式的中间件Elasticsearch，过程中直接存取非结构化数据，减少关联查询。征信管理平台涉及的关键业务流程多，访问量大，因此行内提出了较多的质量属性要求，下面先介绍下软件架构评估的质量属性。</p>
<pre><code>架构评估是软件开发过程中的重要环节，在软件架构评估中的质量属性有：性能、可用性、可修改性、安全性、可测试性、可靠性和易用性等。其中前4个质量属性是质量效应树的重要组成部分。性能是指系统的响应能力，即经过多长时间对事件做出响应。可用性是指系统能够正常运行的比例，通过用两次故障之间的时间长度或出现故障时系统能够恢复的速度来表示。可修改性是指系统能以较高的性价比对系统做出变更的能力。安全性是指系统能够向合法用户提供服务，同时拒绝非授权用户使用或拒绝服务的能力。
常用的架构评估方法有：基于问卷调查的评估方式、基于场景的评估方式和基于度量的评估方式。基于问卷调查的评估方式是由多个评估专家通过调查问卷的方式回答问卷中的问题，对多个评估结果进行综合，最终得到最终结果。其评价的具有主观性不太适合本项目。基于度量的评估方式虽然评价比较客观，但是需要评估者对系统的架构有精确的了解，也不太适合本项目。而基于场景的评估要求评估者对系统中等了解，评价比较主观，故本项目采用了基于场景的评估方式。基于场景的评估方式又分为架构权衡分析法ATAM，软件架构分析法SAAM和成本效益分析法CBAM。本项目中根据不同质量属性使用了ATAM作为系统架构评估的方法。

在使用ATAM进行架构评估时，我们根据项目需要成立了项目评估小组。其主要成员包括：评估小组负责人、项目决策者、架构设计师、用户、开发人员、测试人员、系统部署人员等项目干系人。架构的评估经历了描述和介绍阶段、调查和分析阶段、测试阶段和报告阶段四个阶段。下面我分别从这四个阶段进行介绍。

在描述和介绍阶段，由于项目评估成员有部分人员对ATAM并不熟悉，因此项目组首先学习了ATAM的方法。它是一种基于场景的软件架构评估方法，对系统的多个质量属性基于场景进行评估。通过该评估确认系统存在的风险，并检查各自的非功能性需求是否满足需求。业务重点阐述了系统的目的和举例说明了使用的场景，我也和大家介绍了本次项目中采用的微服务架构，并解析了各模块的功能。

在调查分析阶段，业务部门提出了性能及高可用的要求，因为大量的业务场景需要使用到这些数据，并且部分场景对时间非常敏感。另外开发人员提出为了当不断增加数据供应商时，需要快速的进行接入，保证系统的开发效率及系统修改性，可以进行并行开发。

针对这些场景我们分析了项目开发过程中的风险点、敏感点和权衡点。经过分析，该项目中存在以下风险点：当第三方供应商无法提供服务时，会直接影响业务可用性；敏感点有：用户的加密级别、漏洞规则的修改。权衡点有：为提高可用性，需增加主备模式，当主供应商失效时，能切换至选供应商继续提供服务，但因为主备供应商的报文格式、数据字典都有差异，需要进行标准化，势必影响系统的可修改性。

在测试阶段：经过评估小组集体讨论，确定了不同场景的优先级如下：系统的可用性最高，性能其次，可修改性较低。在保证系统可用性方面，在流量捕获部分使用双机热备技术，在两个捕获系统之间设置心跳，当一台捕获系统出问题，另一台捕获设备接管。在流量自动化分析部分，采用了集群部署技术，一台分析设备出问题，不会影响整个分析系统。在保证数据安全性方面，磁盘采用企业磁盘阵列raid5机制。在用户数据安全性方面，采用了非对称加密及信息摘要技术。

最后形成了评估报告，经过对架构的评估，确定了系统的风险点、敏感点、权衡点和非风险点，最后以文档的形式表现。其包括的内容包括：架构分析方法文档、架构的不同场景及各自的优先级、质量效应树、风险点决策、非风险点决策及每次的评估会议记录。

该项目开发工作于2016年8月完工，系统上线后，我们的安全分析人员和客户使用该系统对互联网流量进行漏洞挖掘，一共产生了150种以上的web流量攻击流量特征和5个未知web漏洞。在国家某安全中心网研室的其他项目中起到了支撑作用，尤其是某变量覆盖漏洞、某文件写入漏洞，某sql注入漏洞在项目使用过程中取得了一定得效果，得到了好评。为开展互联网安全事件得防御、发现、预警和协调处置等工作提供了数据依据，更好的维护了国家公共互联网安全，保障基础信息网络和重要信息系统的安全运行。
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/09/论软件架构的选择/">论软件架构的选择</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-09</time><div class="content"><p>论文摘要</p>
<p>2017年4月份，某股份制银行启动了新征信管理平台的系统项目，本人所在的大数据支持处室负责了数据存储、查询及数据标准化等功能的建设，本人作为项目经办负责技术方案的管理和设计。征信管理平台是我行风险控制的重要部分，维护有个人、对公征信、互联网小贷、电信运营商等数据。征信管理平台承载了大量业务在风险控制环节对数据的诉求，如新发卡、贷前、贷中等关键业务流程。本文介绍了几种主要架构风格及特点，论述了该项目在软件架构选择过程中，为何选择了三种风格的组合。最后，文章总结了采用该组合风格后带来的好处及缺点。</p></div><a class="more" href="/2018/11/09/论软件架构的选择/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/12/《Kafka技术内幕》-读书笔记5/">《Kafka技术内幕》--读书笔记5</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><p>消费者的配置信息要指定连接的ZK集群以及消费组编号。消费者客户端会通过消费者连接器(ConsumerConnector)连接ZK集群，获取分配的分区，创建每个主题对应的消息流(KafkaStream),最后迭代消息流，读取每条消息，并完成具体的业务处理逻辑(这里只是简单地打印出收到的每条信息)。</p>
<p>消费者客户端通过消费者连接器读取消息的具体步骤如下。</p>
<ol>
<li>消费者的配置信息指定订阅的主题和主题对应的线程数，每个线程对应一个消息流。</li>
<li>Consumer对象通过配置文件创建基于ZK的消费者连接器。</li>
<li>消费者连接器根据主题和线程数创建多个消息流。</li>
<li>在每个消息流通过循环消费者迭代器(ConsumerIterator)读出消息。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fve31c9uixj315w0hmap1.jpg" alt=""></p></div><a class="more" href="/2018/09/12/《Kafka技术内幕》-读书笔记5/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/08/《Kafka技术内幕》-读书笔记4/">《Kafka技术内幕》--读书笔记4</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><p>Kafka集群的数据需要被不同类型的消费者使用，而不同类型的消费者处理逻辑不同。Kafka使用消费组的概念，允许一组消费者进程对消费工作进行划分。每个消费者都可以配置一个所属的消费组，并且订阅多个主题。Kafka会发送每条消息给每个消费组中的一个消费者迫二程(同一条消息广播给多个消费组，单播给同一组中的消费者)。被订阅主题的所有分区会平均地负载给订阅方，即消费组中的所有消费者。</p>
<p>Kafka采用消费组保证了“一个分区只可被消费组中的一个消费者所消费”，这意味着:</p>
<ol>
<li>在一个消费组中，一个消费者可以消费多个分区。</li>
<li>不同的消费者消费的分区一定不会重复，所有消费者一起消费所有的分区。</li>
<li>在不同消费组中，每个消费组都会悄费所有的分区。</li>
<li>同一个消费组下消费者对分区是互斥的，而不同消费组之间是共享的。</li>
</ol></div><a class="more" href="/2018/09/08/《Kafka技术内幕》-读书笔记4/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/13/《Kafka技术内幕》-读书笔记3/">《Kafka技术内幕》--读书笔记3</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><h1 id="客户端消息发送线程"><a href="#客户端消息发送线程" class="headerlink" title="客户端消息发送线程"></a>客户端消息发送线程</h1><p>我们先按照分区的主副本节点进行分组，把属于同一个节点的所有分区放在一起，合并成一个请求发送。</p>
<p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fu8gxn3kihj30uq0j2n9f.jpg" alt=""></p></div><a class="more" href="/2018/08/13/《Kafka技术内幕》-读书笔记3/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/18/《Kafka技术内幕》-读书笔记2/">《Kafka技术内幕》--读书笔记2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><p>Kafka初期使用Scala编写，早期Scala版本的生产者、消费者和服务端的实现都放在core包下;而最新的客户端使用了Java重新实现，放在clients包下。</p>
<h1 id="新生产者"><a href="#新生产者" class="headerlink" title="新生产者"></a>新生产者</h1><p>新的生产者应用程序使用KafkaProducer对象代表一个生产者客户端进程。生产者要发送消息，并不是直接发送给服务端，而是先在客户端把消息放入队列中，然后由一个消息发送线程从队列中拉取消息，以批量的方式发送消息给服务端。Kafka的记录收集器(RecordAccumulator)负责缓存生产者客户端产生的消息，发送线程(Sender)负责读取记录收集器的批量消息，通过网络发送给服务端。为了保证客户端网络请求的快速响应，Kafka使用选择器(Selector)处理网络连接和读写处理，使用网络连接(NetworkClient)处理客户端网络请求。</p></div><a class="more" href="/2018/07/18/《Kafka技术内幕》-读书笔记2/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/15/《Kafka技术内幕》-读书笔记1/">《Kafka技术内幕》--读书笔记1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Kafka技术内幕/">Kafka技术内幕</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kafka技术内幕/">Kafka技术内幕</a></span><div class="content"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>生产者 (producer)应用程序发布事件流到Kafka的一个或多个主题。</li>
<li>消费者 (consumer)应用程序订阅Kafka的一个或多个主题，并处理事件流。</li>
<li>连接器 (connector)将Kafka主题和已有数据源进行连接，数据可以互相导人和导出 。</li>
<li>流处理 (processor)从Kafka主题消费输入流，经过处理后，产生输出流到输出主题。</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftax17fddej30u00liqg7.jpg" alt=""></p></div><a class="more" href="/2018/07/15/《Kafka技术内幕》-读书笔记1/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/13/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-13</time><div class="content"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By keon</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>